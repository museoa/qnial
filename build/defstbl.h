/*==================================================================

            defsndf.h

   GENERATED by procpkg.ndf

==================================================================*/

#define NOLINES 627

static char *defsndf[627] = {
"#CORE.NDF - definitions included in all Nial 6.2 versions",
"",
"# the following definitions are kept for compatibility",
"with earlier versions:",
"",
"div is /",
"",
"prod is *",
"",
"truth is true",
"",
"falsehood is false",
"",
"opp is opposite",
"",
"recip is reciprocal",
"",
"istruthvalue is isboolean",
"",
"flip is pack",
"",
"mold is take",
"",
"#gage is OPERATION A { ",
" A := content A;",
" IF and EACH isinteger A THEN",
"    IF tally A = 1 THEN ",
"       IF first A >= 0 THEN first A ELSE ??gage ENDIF",
"    ELSE",
"       IF and EACH (0<=) A THEN list A ELSE ??gage ENDIF",
"    ENDIF",
" ELSE ",
"   ??gage",
" ENDIF }",
"",
"vacate is 0 reshape",
"",
"void is vacate single",
"",
"# end of obsolete definitions",
"",
"# The following names are part of the language and should be",
"included. They are placed here so that internally, the same code",
"is used. The abbreviations appear when the name is displayed.",
"",
"sum is +",
"",
"product is *",
"",
"minus is -",
"",
"divide is /",
"",
"lt is <",
"",
"gt is >",
"",
"lte is <=",
"",
"gte is >=",
"",
"equal is =",
"",
"unequal is ~=",
"",
"# The following abbreviations are included for convenience.",
"",
"inv is inverse",
"",
"ip is innerproduct",
"",
"# the following definitions are considered part of the language, but can be",
"removed if the user does not need them.",
"",
"Pi IS 3.1415926535897932",
"",
"axes IS OPERATION A {tell valence A}",
"",
"post IS OPERATION A { [tally A, 1] reshape A }",
"",
"count IS OPERATION A { 1 + tell A }",
"",
"last IS OPERATION A {tally A - 1 pick list A}",
"",
"notin IS OPERATION A B { not (A in B) }",
"",
"allin IS OPERATION A B { and (A EACHLEFT in B) }",
"",
"like IS OPERATION A B { A allin B and (B allin A) }",
"",
"front IS OPERATION A {",
"        IF empty A THEN",
"                list A",
"        ELSE",
"                tally A - 1 reshape A",
"        ENDIF }",
"",
"takeright IS OPERATION A B {",
"  opposite A take B }",
"",
"dropright IS OPERATION A B {",
"   opposite A drop B }",
"",
"lower IS OPERATION N A {",
" IF isinteger N THEN",
"   IF N < 0 or (N > valence A) THEN",
"     fault '?left arg of lower out of range'",
"   ELSE",
"     valence A - N raise A",
"   ENDIF",
" ELSE",
"   fault '?left arg not an integer'",
" ENDIF }",
"",
"rows IS OPERATION A { valence A min 1 lower A }",
"",
"split IS OPERATION I A {",
"   IF empty A THEN",
"      fault '?empty right arg in split'",
"   ELSEIF not(I allin axes A and diverse I) THEN",
"      fault '?invalid left arg in split'",
"   ELSE",
"     J gets axes A except link I;",
"     tally J raise (J link I fuse A)",
"   ENDIF }",
"",
"blend IS OPERATION I A {",
"   IF empty A THEN",
"      A",
"   ELSE",
"     J gets tell (valence A + valence first A) except I;",
"     GRADE <= (J link I) fuse mix a ",
"   ENDIF }",
"",
"",
"cols IS OPERATION A {",
"  IF valence A = 0 or (a = Null) THEN",
"    single A",
"  ELSE",
"    valence A - 2 max 0 split A",
"  ENDIF }",
"",
"rotate IS OPERATION N A {",
"  IF isinteger N THEN",
"    Ta := tally A;",
"    shape A reshape (Ta + N + tell Ta mod Ta choose list A) ",
"  ELSE",
"    fault '?first arg of rotate not an integer'",
"  ENDIF",
"  }",
"",
"# the generic INNER transformer.  Typical use is INNER [sum,times]",
"or INNER [+,*] .",
"",
"INNER IS TRANSFORMER f g  OPERATION A B {",
"  IF valence A <= 2 THEN",
"     AA := rows A;",
"  ELSE",
"     AA := 1 lower A;",
"  ENDIF;",
"  IF valence B <= 2 THEN",
"     BB := cols B;",
"  ELSE",
"     BB := 1 raise B;",
"  ENDIF;",
"  EACH f (AA OUTER (EACHBOTH g) BB) }",
"",
"",
"# the following two transformers are intended to be applied to operations",
"that map lists to lists such as reverse and (N rotate). The resulting",
"transform is intended to be used on a two-dimensional array.",
"",
"BYROWS IS TRANSFORMER f OPERATION A {",
"       1 RANK f A }",
"",
"BYCOLS IS TRANSFORMER f OPERATION A {",
"       transpose (1 RANK f transpose A) }",
"",
"PARTITION IS TRANSFORMER f OPERATION Ij A {",
"  IF empty Ij or (tally Ij > 2) THEN",
"    fault 'invalid left arg of PARTITION transform'",
"  ELSEIF empty A THEN",
"    A",
"  ELSE",
"    IF tally Ij = 1 THEN",
"       I := J := first Ij;",
"    ELSEIF tally Ij=2 THEN",
"       I J := Ij;",
"    ENDIF;",
"    II gets axes A except I link I;",
"    B := tally I RANK f (II fuse A);",
"    IF J = Null and (shape B = Null) THEN",
"      first B",
"    ELSEIF tally J = (valence B - (valence A - tally I)) THEN",
"      JJ gets axes B except J link J;",
"      GRADE <= JJ fuse B",
"    ELSE",
"      fault 'left arg incompatible with function in PARTITION transform'",
"    ENDIF",
"  ENDIF }",
"",
"",
"",
"# the following two transformers are intended to be applied to operations",
"that are binary or reductive such as sum, max, or /. The resulting",
"transform is intended to be used on a multi-dimensional array (valence >=2).",
"",
"REDUCEROWS IS TRANSFORMER f OPERATION A {",
"   BYROWS (REDUCE f) A }",
"",
"REDUCECOLS IS TRANSFORMER f OPERATION A {",
"   [valence A - 2 max 0,axes first A] PARTITION (REDUCE f) A }",
"",
"# file path Separator",
"",
"Separator IS {",
"  IF System = \"Windows THEN ",
"     `\\",
"  ELSEIF System = \"UNIX THEN",
"     `/",
"  ELSE fault ",
"     '?No Separator specified'",
"  ENDIF",
"}",
"",
"# routine to compute a filepath from directory names and a filename",
"",
"filepath is op Nms {",
"  front link (EACH string Nms EACHLEFT append Separator ) }",
"",
"Libpath := Null;",
"",
"# the following definitions are kept for compatibility",
"",
"library IS OPERATION Arg {",
"  Librarylist IS {",
"   IF System = \"Windows  THEN",
"      Libs := 'C:\\QNialV63\\' EACHRIGHT link ['niallib'] ;",
"   ELSEIF System = \"UNIX THEN",
"      Libs := ['../niallib'] ;",
"   ELSE",
"      Libs := fault '?No Library list specified';",
"   ENDIF;",
"   % you may extend the list of libs to include any other directories of",
"     Nial definitions;",
"   Libs };",
"  IF tally Arg = 2 and not isstring Arg THEN",
"    Filename Mode := Arg;",
"  ELSE",
"    Filename := Arg;",
"    Mode := 0;",
"  ENDIF;",
"  Libs := Libpath link Librarylist;",
"  % turn off fault triggering in case the loaddefs faults;",
"  Svtrigger := settrigger False;",
"  Found := False;",
"  WHILE not Found and not empty Libs DO",
"    Libtotry Libs := [first,rest] Libs;",
"    Pathtofile := link Libtotry Separator (string Filename);",
"    Res := loaddefs Pathtofile Mode;",
"    IF Res = ??noexpr THEN",
"      Found := True;",
"    ENDIF;",
"  ENDWHILE;",
"  settrigger Svtrigger;",
"  Res }",
"",
"# fault builder to avoid triggering.",
"",
"quiet_fault is OPERATION Str {",
"   Oldsetting := settrigger o;",
"   Res := fault Str;",
"   settrigger Oldsetting;",
"   Res }",
"",
"# definitions of APL-like catenation forms.",
"  A is the list of objects to be joined. For example, if A is C D E, then:",
"  I catenate C D E joins C D and E along the Ith axis",
"  I LAMINATE C D E creates a new axis of length 3 before axis I.",
"",
"catenate IS OPERATION I A {",
"   % push down I axis of items of A;",
"   B := EACH ( I split ) A ;",
"   IF equal EACH shape B THEN",
"      I blend EACH link pack B",
"   ELSE",
"      fault '?conform error in catenate'",
"   ENDIF }",
"",
"laminate IS OPERATION I A {",
"   IF equal EACH shape A THEN",
"      Axesofitems := axes first A;",
"         link (I take Axesofitems) (I drop Axesofitems + 1) blend A",
"   ELSE",
"      fault '?conform error in laminate'",
"   ENDIF }",
"",
"sortup is SORT up",
"",
"gradeup is GRADE up",
"",
" ",
"# timing function that write the time and returns the result",
"",
"TIMEIT IS TRANSFORMER f",
"    OPERATION A { ",
"       T gets Time;",
"       Val := f A;",
"       write (Time - T); ",
"       Val }",
" ",
" ",
"Vars IS { Syms := symbols 0;",
"      IF empty Syms THEN",
"         Null",
"      ELSE",
"         Names Roles  := pack Syms;",
"         \"var match Roles sublist Names ",
"      ENDIF }",
"",
"Exprs IS { Syms := symbols 0;",
"      IF empty Syms THEN",
"         Null",
"      ELSE",
"         Names Roles  := pack Syms;",
"         \"expr match Roles sublist Names ",
"      ENDIF }",
"",
"Ops IS { Syms := symbols 0;",
"      IF empty Syms THEN",
"         Null",
"      ELSE",
"         Names Roles  := pack Syms;",
"         \"op match Roles sublist Names ",
"      ENDIF }",
"",
"Trs IS { Syms := symbols 0;",
"      IF empty Syms THEN",
"         Null",
"      ELSE",
"         Names Roles  := pack Syms;",
"         \"tr match Roles sublist Names ",
"      ENDIF }",
"",
"getsyms is op Defn_name {",
"  varnames is op Root {",
"   IF Root = quiet_fault '?Grnd' THEN",
"     Null",
"   ELSE",
"     first Root hitch (varnames Root@3) link (varnames Root@4)",
"   ENDIF };",
"   varnames first second third second getdef Defn_name }",
"",
"FILTER IS TRANSFORMER f OPERATION A { EACH f A sublist A }",
"",
"depth IS OPERATION A ",
"{ IF atomic A THEN",
"    0",
"  ELSE",
"    1 + (max EACH depth A)",
"  ENDIF } ",
"",
"",
"",
"# REGULAR EXPRESSION OPERATIONS added at the Nial level",
"",
"",
"# The following operations are provided at the C level:",
"#",
"#    _regexp_m  <regular expr> <string> <options>",
"#",
"#       <regular expr>: described below",
"#       <string>      : the string to be acted upon",
"#       <options>     : can be the character 'i' which ",
"#                       means to ignore case    ",
"#",
"#       RESULT        : the result is 0 if no match was found,",
"#                       or a positive integer to indicate that",
"#                       a match was found and how many sub expression",
"#                       were found",
"#",
"#    _regexp_s  <regular expr> <replacement str> <string> <options>",
"#",
"#       <regular expr>   : described below",
"#       <replacement str>: a string to replace the entire <regular expression>.",
"#                          The string may also include $0-$9.  $0 will be",
"#                          replaced with the entire source string, and $1-$9",
"#                          will be replaced by the bracketed subexpression",
"#                          matched by <regular expr>",
"#       <string>         : the string to be acted upon",
"#       <options>        : can be the character 'i' (which ",
"#                          means to ignore case) or 'g' (which means",
"#                          to replace more than on occurence (recursively!)",
"#                          or both 'i' and 'g'",
"#       RESULT           : The resulting string (possible the same as the original",
"#                          if not match) is returned.",
"#",
"#    _regexp_tr <char list> <repl char list> <string> <options>",
"#",
"#      <char list>    : list of characters to look for in the <String>",
"#      <repl list>    : list of characters to replace the characters in",
"#                       <char list>.  IF <repl list> longer than one character",
"#                       then there is a one-one mapping between the <char list>",
"#                       and the <repl list>.  If the <repl list> is shorter",
"#                       than the <char list>, the last character of the <repl list>",
"#                       is replicated as necessary.",
"#      <string>       : source string",
"#      <options>      : 'd' = delete option. If <char list> is longer that",
"#                             <repl list> by n chars, then any occurence",
"#                             of the last n char of <char list> in <string>",
"#                             will be deleted from <string>, instead of being mapped",
"#                             to the last character of <repl list>.",
"#                       'c' = compliment (NOT in <string>), only last character",
"#                             from <repl list> is used in this case.",
"#                       's' = squeeze multiple char from <char list> into",
"#                             single replacement char from <repl list> ",
"#      RESULT         : The result is the modified string.",
"#",
"#    _regexp_getsub <index>",
"#",
"",
"",
"regexp_match IS OP args {",
"  pattern := first args;",
"  str := second args;",
"  if tally args = 3 then",
"    opts := third args;",
"  else",
"    opts := ' ';",
"  endif;",
"  rc :=  _regexp_m pattern str opts; ",
"  IF and (not isfault rc) (rc >= 0) THEN",
"    l",
"  ELSE",
"    o",
"  ENDIF",
"}",
"",
"",
"regexp_substitute IS OP args {",
"  pattern := first args;",
"  repl := second args;",
"  str := third args;",
"  if tally args = 4 then",
"    opts := 3 pick args;",
"  else",
"    opts := ' ';",
"  endif;",
"  _regexp_s pattern repl str opts",
"}",
"",
"",
"string_translate IS OP args {",
"  pattern := first args;",
"  repl := second args;",
"  str := third args;",
"  if tally args = 4 then",
"    opts := args@3;",
"  else",
"    opts := ' ';",
"  endif;",
"  _regexp_tr pattern repl str opts",
"}",
"",
"",
"",
"",
"",
"regexp IS OP pattern str {",
"  IF empty str THEN",
"    rc := -1;",
"  ELSE",
"    rc := _regexp_m pattern str ' ';",
"  ENDIF;",
"  IF rc = -1 THEN",
"    [o,NULL]",
"  ELSE",
"    res := [l];",
"    IF rc >= 1 THEN",
"      FOR i WITH tell rc DO",
"        res := res append (_regexp_getsub i);",
"      ENDFOR;",
"    ENDIF;",
"    res",
"  ENDIF",
"}",
"",
"",
"",
"# This is an iterative version of the split routine",
"",
"string_split IS OP args {",
"  pattern := first args;",
"  str := second args;",
"  limit := -1;",
"  IF tally args = 3 THEN",
"    limit := (third args);",
"  ENDIF;",
"  IF empty pattern THEN",
"    each solitary str",
"  ELSE",
"    done := o;",
"    result := null;",
"    REPEAT",
"    IF (limit <= -1) and ((empty str) or (isfault str)) THEN",
"      done := l;",
"    ELSE",
"      res := regexp  (link '^([' pattern '])(.*)') str;",
"      if (first res) and ((limit >= 2) or (limit <= -1)) THEN",
"        limit := limit - 1;",
"        str := res@3;",
"        result := result append null;",
"      ELSE",
"        res := regexp  (link '([^' pattern ']*)([' pattern '])(.*)')  str;",
"        if (first res) and ((limit >= 2) or (limit <= -1)) THEN",
"          limit := limit - 1;",
"          str := res@4;",
"          result := result append res@2;",
"        ELSE",
"          result := result append str;",
"          str := null;",
"          done := true;",
"        ENDIF",
"      ENDIF",
"    ENDIF",
"    UNTIL (done)",
"    ENDREPEAT;",
"  ENDIF;",
"  result",
"}",
"",
"",
"",
"# high level routines for socket communication ",
"",
"MAXLENGTH IS 1000",
"",
"check_socket IS OP Arg {",
"  NONLOCAL Return_status;",
"  IF isfault Arg and (Arg ~= ??noexpr) THEN",
"    write Arg;",
"    Return_status := 'Connection_lost';",
"    Toplevel;",
"  ENDIF;",
"  Arg }",
"",
"socket_read IS OP socket {",
"  Len := check_socket socket_receive socket 1 l;",
"  %write 'received Len: ' Len;",
"  %write 'type' (type Len);",
"  str := '';",
"  WHILE len - tally Str > MAXLENGTH DO",
"    Piece := socket_receive socket MAXLENGTH o;",
"    Str := Str link Piece;",
"  ENDWHILE;",
"  Str := Str link socket_receive socket (len - tally Str) o;",
"  %write 'received Str ' Str;",
"  %write 'received type' (type Str);",
"  %write link 'received string of length ' (string tally Str);",
"  Res := execute Str;",
"  %write link 'containing ' (string tally content Res) ' atoms';",
"  Res",
"}",
"",
"",
"socket_write IS OP socket array {",
"  str := display array;",
"  len := tally str;",
"  check_socket socket_send socket len l;",
"  WHILE tally str > MAXLENGTH DO",
"    piece str := MAXLENGTH [take,drop] str;",
"    socket_send socket piece o;",
"  ENDWHILE;",
"  socket_send socket str o;",
"  %write link 'sent string of length ' (string tally Str);",
"  %write link 'containing ' (string tally content array) ' atoms';",
"}",
"",
"",
"socket_getline IS OP socket echo echostar remoteecho {",
" nllist IS char (0 10 13);",
" input := null;",
" nl1 := list char 13;",
" nl2 := list char 10;",
" REPEAT",
"  % get the next char;",
"  inp := socket_receive socket 1 o;",
"  IF isfault inp THEN",
"    exit null;",
"  ENDIF;",
"  %-- if it is not a new line then use it;",
"  IF inp ~= nl1 THEN",
"    %-- add it to the end of our string;",
"    input := input link inp;",
"    IF echo THEN ",
"      IF echostar THEN",
"        socket_send socket '*';",
"      ELSE",
"        socket_send socket inp;",
"      ENDIF;",
"    ENDIF;",
"  ELSE",
"    %-- NON Blocking peek at the next character;",
"    %-- depending on the client, there is sometimes a extra NULL or other nl char;",
"    %-- character waiting;",
"    inp2 := socket_peek socket 1 o;",
"    if (first inp2) in nllist THEN",
"      %-- if we got a NULL then gobble it up;",
"      inp2 := socket_receive socket 1 o;",
"    ENDIF;",
"    IF remoteecho THEN",
"     socket_send socket nl1;",
"     socket_send socket nl2;",
"     exit input;",
"    ENDIF;",
"    IF (inp2 = nl2)  THEN",
"      IF echo THEN",
"        socket_send socket nl1;",
"        socket_send socket nl2;",
"      ENDIF;",
"      exit input;",
"    ENDIF",
"  ENDIF;",
" UNTIL o",
" ENDREPEAT",
"}",
"",
};
